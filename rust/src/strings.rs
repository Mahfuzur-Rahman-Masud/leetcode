use std::cmp::max;

#[allow(dead_code)]
pub fn is_isomorphic(s: String, t: String) -> bool {
    if s.len() != t.len() {
        return false;
    }

    let bs = s.as_bytes();
    let bt = t.as_bytes();

    let mut st: [usize; 130] = [0; 130];
    let mut ts: [usize; 130] = [0; 130];

    for i in 0..s.len() {
        let s = bs[i];
        let t = bt[i];

        if st[s as usize] != ts[t as usize] {
            return false;
        }

        st[s as usize] = i + 1;
        ts[t as usize] = i + 1;
    }

    true
}

#[allow(dead_code)]
pub fn is_anagram(s: String, t: String) -> bool {
    if s.len() != t.len() {
        return false;
    }


    let mut cs = [0_i16; 26];


    for c in s.chars() {
        cs[c as usize - 97] += 1;
    }

    for c in t.chars() {
        let i = c as usize - 97;
        cs[i] -= 1;
        if cs[i] < 0 {
            return false;
        }
    }

    true
}

#[allow(dead_code)]
pub fn can_construct(ransom_note: String, magazine: String) -> bool {
    let mut cc: [i32; 200] = [0; 200];


    for c in magazine.chars() {
        cc[c as usize] += 1;
    }

    for c in ransom_note.chars() {
        let x = &mut cc[c as usize];
        if x == &0 {
            return false;
        }
        *x -= 1;
    }

    true
}

// Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
#[allow(dead_code)]
pub fn first_uniq_char(s: String) -> i32 {
    let mut cc = [0; 123];

    for c in s.chars() {
        cc[c as usize] += 1;
    }

    for (i, c) in s.chars().enumerate() {
        if cc[c as usize] == 1 {
            return i as i32;
        }
    }

    -1
}

//String t is generated by random shuffling string s and then add one more letter at a random position.
//
// Return the letter that was added to t
#[allow(dead_code)]
pub fn find_the_difference_1(s: String, t: String) -> char {
    let mut sum = 0;
    s.chars().for_each(|c| sum -= c as i32);
    t.chars().for_each(|c| sum += c as i32);
    sum as u8 as char
}

#[allow(dead_code)]
pub fn find_the_difference(s: String, t: String) -> char {
    let a = s.as_bytes();
    let b = t.as_bytes();

    for i in 0..a.len() {
        if a[i] != b[i] {
            return b[i] as char;
        }
    }

    b[b.len() - 1] as char
}


//Given a string s, return the longest
// palindromic
//
// substring
//  in s.
#[allow(dead_code)]
pub fn longest_palindrome_fails(s: String) -> String {
    let b = s.as_bytes();
    let mut max = 0;
    let mut l = 0;
    let mut r = 0;
    let size = b.len();


    let mut x = 0;
    while x < size {
        let c = b[x];
        let mut y = x;
        let mut len = y - x + 1;
        while y < size {
            if b[y] == c {
                len = y - x + 1;
                y += 1;
            } else {
                break;
            }
        }


        if len > max {
            max = len;
            l = x;
            r = x + len - 1;
        }
        x = y;
    }

    if max > 2 * size / 3 + 1 {
        return (&s[l..=r]).to_string();
    }


    let lbound = match l {
        0 => r + 1,
        _ => 1
    };

    println!("lbound {}", lbound);

    for i in lbound..size - 1 {
        let mut x = i as i32;
        let mut y = i;


        if b[i - 1] == b[i] && b[i] != b[i + 1] {
            x -= 1;
        }

        while x >= 0 && y < size {
            let xx = x as usize;
            if b[xx] == b[y] {
                let len = y - xx + 1;
                if len > max {
                    max = len;
                    l = xx;
                    r = y;
                }

                x -= 1;
                y += 1;
            } else {
                break;
            }
        }
    }


    (&s[l..=r]).to_string()
}

#[allow(dead_code)]
pub fn longest_palindrome(s: String) -> String {
    let b = s.as_bytes();
    let mut max = 0;
    let mut l = 0;
    let mut r = 0;
    let size = b.len();
    let mut x = 0;
    let mut y;

    while x < size - 1 {
        // identify core---------------
        let c = b[x];
        y = x + 1;
        while y < size {
            if b[y] == c {
                y += 1;
            } else {
                break;
            }
        }
        y -= 1;


        // explore span---------------
        {
            let mut x = x as i32;
            while x >= 0 && y < size {
                let xx = x as usize;
                if b[y] == b[xx] {
                    let len = y - xx + 1;
                    if len > max {
                        max = len;
                        l = xx;
                        r = y;
                    }
                    y += 1;
                    x -= 1;
                } else {
                    break;
                }
            }
        }

        x += 1;
    }

    (&s[l..=r]).to_string()
}

#[allow(dead_code)]
pub fn convert(s: String, num_rows: i32) -> String {
    if num_rows == 1 {
        return s;
    }

    let b = s.as_bytes();
    let mut out: Vec<u8> = Vec::<u8>::with_capacity(b.len());
    let len = b.len();


    let span = num_rows as usize - 1;
    for row in 0..=span {
        let mut x = row;
        let mut left = true;
        while x < len {
            out.push(b[x]);

            let gap = span - row;
            if row == 0 || row == span {
                x += span * 2;
            } else if left {
                x += gap * 2;
            } else {
                x += (span - gap) * 2;
            }

            left = !left;
        }
    }


    unsafe { String::from_utf8_unchecked(out) }
}


#[allow(dead_code)]
pub fn longest_palindrome_from_rearrange(s: String) -> i32 {
    let mut mx = 0;
    let mut sum = 0;
    let mut counter = [0; 123];
    for c in s.as_bytes() {
        counter[*c as usize] += 1;
    }

    for i in 65..123 {
        let count = counter[i];

        if count > mx {
            if mx % 2 != 0 {
                sum -= 1;
            }

            mx = count;
            sum += count;
        } else if count % 2 == 0 {
            sum += count;
        } else {
            sum += count - 1;
        }
    }

    if sum < s.len() && mx % 2 == 0 {
        sum += 1;
    }


    sum as i32
}

#[allow(dead_code)]
pub fn add_strings2(num1: String, num2: String) -> String {
    let a = num1.as_bytes();
    let b = num2.as_bytes();
    let len = max(num1.len(), num2.len());
    let oa = len - a.len();
    let ob = len - b.len();

    let mut out = Vec::with_capacity(len * 2);
    let mut carry: u8 = 0;
    let mut ii = len as i32 - 1;
    while ii >= 0 {
        let i = ii as usize;

        if i >= oa {
            carry += a[i - oa] - 48;
        }
        if i >= ob {
            carry += b[i - ob] - 48;
        }


        out.push(carry % 10 + 48);
        carry /= 10;


        ii -= 1;
    }

    if carry != 0 {
        out.push(carry + 48)
    }

    out.reverse();
    unsafe { String::from_utf8_unchecked(out) }
}

#[allow(dead_code, unused_variables)]
pub fn add_strings_faster(num1: String, num2: String) -> String {
    let a = num1.as_bytes();
    let b = num2.as_bytes();
    let len = if a.len() > b.len() { a.len() } else { b.len() };
    let oa = len - a.len();
    let ob = len - b.len();
    let mut out = vec![0; len + 1];
    let mut digit = 0;

    for i in (0..len).rev() {
        if i >= oa {
            digit += a[i - oa] - 48;
        }

        if i >= ob {
            digit += b[i - ob] - 48;
        }

        if digit > 9 {
            out[i + 1] = digit - 10 + 48;
            digit = 1;
        } else {
            out[i + 1] = digit + 48;
            digit = 0;
        }
    }


    return if digit > 0 {
        out[0] = digit + 48;
        unsafe { String::from_utf8_unchecked(out) }
    } else {
        unsafe { std::str::from_utf8_unchecked(&out[1..]).to_string() }
    };
}

#[allow(dead_code)]
pub fn add_strings(num1: String, num2: String) -> String {
    let (a, b) = if num1.len() > num2.len() {
        (num2.as_bytes(), num1.as_bytes())
    } else {
        (num1.as_bytes(), num2.as_bytes())
    };


    let len = b.len();
    let oa = len - a.len() + 1;
    let ob = len - b.len() + 1;

    let mut out = vec![0; len + 1];
    let mut carry = 0;

    for i in (0..a.len()).rev() {
        out[i + oa] = a[i]
    }

    for i in (0..b.len()).rev() {
        let d = &mut out[i + ob];
        *d += b[i] + carry;
        if *d > 95 {
            *d -= 48;
        }

        if *d > 57 {
            carry = 1;
            *d -= 10;
        } else {
            carry = 0;
        }
    }

    return if carry > 0 {
        out[0] += 49;
        unsafe { String::from_utf8_unchecked(out) }
    } else {
        unsafe { std::str::from_utf8_unchecked(&out[1..]).to_string() }
    };
}

#[allow(dead_code)]
pub fn count_segments(s: String) -> i32 {
    let mut spacing = true;
    let mut count = 0;

    for c in s.chars() {
        if c == ' ' {
            spacing = true;
        } else if spacing {
            count += 1;
            spacing = false;
        }
    }

    count
}

#[allow(dead_code)]
fn repeated_substring_pattern(s: String) -> bool {
    let b = s.as_bytes();
    let length = b.len();
    // let c = b[0];

    'next: for segments in 2..=length {
        if length % segments != 0 {
            // println!("Fail on mod test: {}", segments);
            continue;
        }

        let segment_size = length / segments;

        for i in 0..segment_size {
            let c = b[i];
            for j in 1..segments {
                if b[j * segment_size + i] != c {
                    // println!("mismatch {},  {} => {} {}",i, j*segment_size +i,  c, b[j*segment_size + i]);
                    continue 'next;
                }
                // else{
                // println!("size:{} | segments: {}, i: {} {} == {}",segment_size,segments, i, c, b[j*segment_size + i])
                // }
            }
        }

        return true;
    }

    false
}

#[allow(dead_code)]
// if string is concat to itself and first and last chars are removed still the string would 
// contain the original string if it is a repeating pattern
fn repeated_substring_pattern_o1(s: String) -> bool {
    let mut ss = s.clone();
    ss.push_str(&s);
    let sub = &ss[1..ss.len() - 1];
    sub.contains(&s)
}


pub fn int_to_roman(num: i32) -> String {
    let mut roman = "".to_string();

    let romans = [(1000, "M"), (900, "CM"), (500, "D"), (400, "CD"), (100, "C"), (90, "XC"), (50, "L"), (40, "XL"), (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")];

    let mut n = num;

    for (v, r) in romans {
        while n >= v {
            roman.push_str(r);
            n -= v;
        }
    }

    roman
}


#[allow(dead_code)]
pub fn int_to_roman2(num: i32) -> String {
    let mut b = Vec::with_capacity(64);
    let mut n = num;
    while n >= 1000 {
        b.push('M');
        n -= 1000;
    }

    if n >= 900 {
        b.push('C');
        b.push('M');
        n -= 900;
    }

    while n >= 500 {
        b.push('D');
        n -= 500;
    }


    if n >= 400 {
        b.push('C');
        b.push('D');
        n -= 400;
    }

    while n >= 100 {
        b.push('C');
        n -= 100;
    }


    if n >= 90 {
        b.push('X');
        b.push('C');
        n -= 90;
    }

    while n >= 50 {
        b.push('L');
        n -= 50;
    }

    if n >= 40 {
        b.push('X');
        b.push('L');
        n -= 40;
    }

    while n >= 10 {
        b.push('X');
        n -= 10;
    }

    if n >= 9 {
        b.push('I');
        b.push('X');
        n -= 9;
    }

    while n >= 5 {
        b.push('V');
        n -= 5;
    }

    if n >= 4 {
        b.push('I');
        b.push('V');
        n -= 4;
    }


    while n >= 1 {
        b.push('I');
        n -= 1;
    }

    b.into_iter().collect()
}

#[allow(dead_code)]
pub fn detect_capital_use(word: String) -> bool {
    let l = word.len();
    if l < 2 {
        return true;
    }

    let b = word.into_bytes();
    let start = if b[0] < 97 { 1 } else { 0 };
    let is_capital = b[start] < 97;

    for i in 1..l {
        if is_capital != (b[i] < 97) {
            return false;
        }
    }


    true
}

#[allow(dead_code)]
pub fn reverse_str(s: String, k: i32) -> String {
    let mut b = s.into_bytes();
    let mut rev = true;
    let l = b.len();
    let k = k as usize;
    let mut mark_in = 0;
    let mut mark_out = k - 1;

    while mark_in < l {
        if mark_out >= l {
            mark_out = l - 1;
        }

        if rev {
            let (mut mi, mut mo) = (mark_in, mark_out);
            while mi < mo {
                let t = b[mo];
                b[mo] = b[mi];
                b[mi] = t;

                mi += 1;
                if mo > 0 { mo -= 1; }
            }
        }

        rev = !rev;
        mark_in = mark_out + 1;
        mark_out += k;
    }


    unsafe { String::from_utf8_unchecked(b) }
}


#[allow(dead_code)]
pub fn check_record(s: String) -> bool {
    let mut absent = 0;
    let mut late = 0;

    for c in s.chars() {
        if c == 'L' {
            late += 1;
            if late == 3 { return false; } else { continue; }
        }

        late = 0; // Break from consecutive late

        if c == 'A' {
            absent += 1;
            if absent == 2 { return false; }
        }
    }

    true
}

// pub fn reverse_words(s: String) -> String {
//     let mut b = s.into_bytes();
//     let len = b.len();
//     let end = len - 1;
//     let (mut mark_in, mut mark_out) = (0, 1);
//
//     while mark_in < mark_out && mark_out < len {
//         if b[mark_out] == 32 || mark_out == end {
//             let (mut mi, mut mo) = (mark_in, mark_out - 1);
//             if mark_out == end { mo += 1; }
//
//             while mi < mo {
//                 let t = b[mi];
//                 b[mi] = b[mo];
//                 b[mo] = t;
//                 mi += 1;
//                 mo -= 1;
//             }
//
//
//             mark_out += 1;
//             mark_in = mark_out;
//         }
//         mark_out += 1;
//     }
//
//     unsafe { String::from_utf8_unchecked(b) }
// }


// #[allow(dead_code)]
// fn reverse_wrd(mut s: String)->String {
//
//     let mut b = unsafe { s.as_bytes_mut() };
//     let mut mark_in =0;
//     let len = b.len();
//
//     let mut rev = |mut mark_in: usize, mut mark_out: usize| {
//         while mark_in < mark_out {
//             b.swap(mark_in, mark_out);
//             mark_in+=1;
//             mark_out+=1;
//         }
//     };
//
//     for mark_out in 1..len{
//         let v = b[mark_out];
//         if v == 32{
//             rev(mark_in, mark_out);
//             mark_in = mark_out+1;
//         }
//     }
//
//     rev(mark_in, len-1);
//
//     s
// }


#[cfg(test)]
mod test {
    use std::{assert_eq, println};

    use crate::strings::{add_strings, can_construct, check_record, convert, count_segments, detect_capital_use, find_the_difference, find_the_difference_1, first_uniq_char, int_to_roman, int_to_roman2, is_anagram, is_isomorphic, longest_palindrome, longest_palindrome_from_rearrange, repeated_substring_pattern, repeated_substring_pattern_o1, reverse_str};



    // #[test]
    // fn reverse_words_test() {
    //     assert_eq!("ba", reverse_words("ab".to_string()).as_str());
    //     assert_eq!("ba ba", reverse_words("ab ab".to_string()).as_str());
    //     assert_eq!("ba b", reverse_words("ab b".to_string()).as_str());
    //     assert_eq!("a b", reverse_words("a b".to_string()).as_str());
    //     assert_eq!("ax b", reverse_words("xa b".to_string()).as_str());
    //     assert_eq!("ax sab", reverse_words("xa bas".to_string()).as_str());
    // }

    #[test]
    fn check_records_test() {
        assert!(check_record("PPALLP".to_string()));
        assert!(!check_record("PPALLLP".to_string()));
        assert!(check_record("PPLALLP".to_string()));
        assert!(!check_record("PPALALLP".to_string()));
        assert!(check_record("PLLPLLALLP".to_string()));
        assert!(check_record("PPPP".to_string()));
        assert!(!check_record("PPPPAA".to_string()));
        assert!(!check_record("PPALLL".to_string()));
    }

    #[test]
    fn reverse_str_test() {
        assert_eq!("bacdfeg".to_string(), reverse_str("abcdefg".to_string(), 2));
        assert_eq!("bacd".to_string(), reverse_str("abcd".to_string(), 2));
        assert_eq!("ba".to_string(), reverse_str("ab".to_string(), 2));
        assert_eq!("bac".to_string(), reverse_str("abc".to_string(), 2));
        assert_eq!("a".to_string(), reverse_str("a".to_string(), 2));
        assert_eq!("abcde".to_string(), reverse_str("abcde".to_string(), 1));
        assert_eq!("cbadefihg".to_string(), reverse_str("abcdefghi".to_string(), 3));
    }

    #[test]
    fn detect_capital_use_test() {
        assert!(detect_capital_use("".to_string()));
        assert!(detect_capital_use("a".to_string()));
        assert!(detect_capital_use("A".to_string()));
        assert!(detect_capital_use("Ab".to_string()));
        assert!(detect_capital_use("AA".to_string()));
        assert!(detect_capital_use("aa".to_string()));
        assert!(!detect_capital_use("aA".to_string()));
        assert!(detect_capital_use("abba".to_string()));
        assert!(detect_capital_use("ABBA".to_string()));
        assert!(!detect_capital_use("aXst".to_string()));
        assert!(!detect_capital_use("abbA".to_string()));
        assert!(!detect_capital_use("ABBa".to_string()));
        assert!(detect_capital_use("Abba".to_string()));
    }

    #[test]
    fn int_to_romans_test() {
        assert_eq!("L", int_to_roman(50));
        assert_eq!("VII", int_to_roman(7));
        assert_eq!("VIII", int_to_roman(8));
        assert_eq!("IX", int_to_roman(9));

        assert_eq!("D", int_to_roman(500));
        assert_eq!("CDL", int_to_roman(450));
        assert_eq!("CM", int_to_roman(900));
        assert_eq!("CMLVII", int_to_roman(957));


        assert_eq!("L", int_to_roman2(50));
        assert_eq!("VII", int_to_roman2(7));
        assert_eq!("VIII", int_to_roman2(8));
        assert_eq!("IX", int_to_roman2(9));

        assert_eq!("D", int_to_roman2(500));
        assert_eq!("CDL", int_to_roman2(450));
        assert_eq!("CM", int_to_roman2(900));
        assert_eq!("CMLVII", int_to_roman2(957));
    }

    #[test]
    fn repeated_substring_pattern_test() {
        assert!(repeated_substring_pattern("abab".to_string()));
        assert!(!repeated_substring_pattern("aba".to_string()));
        assert!(!repeated_substring_pattern("abac".to_string()));
        assert!(repeated_substring_pattern("aaaaa".to_string()));
        assert!(repeated_substring_pattern("aa".to_string()));
        assert!(!repeated_substring_pattern("a".to_string()));
        assert!(repeated_substring_pattern("abcabcabcabc".to_string()));
        assert!(repeated_substring_pattern("dogdobdogdob".to_string()));
        assert!(repeated_substring_pattern("dogdogdog".to_string()));
        assert!(repeated_substring_pattern("milkmilkmilkmilk".to_string()));
        assert!(repeated_substring_pattern("honeyhoney".to_string()));


        assert!(repeated_substring_pattern_o1("abab".to_string()));
        assert!(!repeated_substring_pattern_o1("aba".to_string()));
        assert!(!repeated_substring_pattern_o1("abac".to_string()));
        assert!(repeated_substring_pattern_o1("aaaaa".to_string()));
        assert!(repeated_substring_pattern_o1("aa".to_string()));
        assert!(!repeated_substring_pattern_o1("a".to_string()));
        assert!(repeated_substring_pattern_o1("abcabcabcabc".to_string()));
        assert!(repeated_substring_pattern_o1("dogdobdogdob".to_string()));
        assert!(repeated_substring_pattern_o1("dogdogdog".to_string()));
        assert!(repeated_substring_pattern_o1("milkmilkmilkmilk".to_string()));
        assert!(repeated_substring_pattern_o1("honeyhoney".to_string()));
    }

    #[test]
    fn count_segments_test() {
        assert_eq!(5, count_segments("Hello, my name is John".to_string()));
        assert_eq!(1, count_segments("Hello".to_string()));
        assert_eq!(0, count_segments("".to_string()));
        assert_eq!(0, count_segments(" ".to_string()));
        assert_eq!(0, count_segments(" ".to_string()));
        assert_eq!(2, count_segments(" aba bd".to_string()));
        assert_eq!(2, count_segments("    aba    bd ".to_string()));
    }

    #[test]
    fn add_strings_test() {
        assert_eq!("5".to_string(), add_strings("3".to_string(), "2".to_string()));
        assert_eq!("0".to_string(), add_strings("0".to_string(), "0".to_string()));
        assert_eq!("10".to_string(), add_strings("0".to_string(), "10".to_string()));
        assert_eq!("11".to_string(), add_strings("1".to_string(), "10".to_string()));
        assert_eq!("105".to_string(), add_strings("95".to_string(), "10".to_string()));
        assert_eq!("10".to_string(), add_strings("1".to_string(), "9".to_string()));
        assert_eq!("16".to_string(), add_strings("7".to_string(), "9".to_string()));
        assert_eq!("533".to_string(), add_strings("456".to_string(), "77".to_string()));
        assert_eq!("533".to_string(), add_strings("77".to_string(), "456".to_string()));
    }

    #[test]
    fn longest_palindrome_from_rearrange_test() {
        assert_eq!(1, longest_palindrome_from_rearrange("a".to_string()));
        assert_eq!(7, longest_palindrome_from_rearrange("abccccdd".to_string()));
        assert_eq!(1, longest_palindrome_from_rearrange("a".to_string()));
        assert_eq!(3, longest_palindrome_from_rearrange("aac".to_string()));
        assert_eq!(3, longest_palindrome_from_rearrange("aaac".to_string()));
        assert_eq!(5, longest_palindrome_from_rearrange("aaacc".to_string()));
        assert_eq!(4, longest_palindrome_from_rearrange("aacc".to_string()));
        assert_eq!(5, longest_palindrome_from_rearrange("aaccx".to_string()));
        assert_eq!(55, longest_palindrome_from_rearrange("zeusnilemacaronimaisanitratetartinasiaminoracamelinsuez".to_string()));
        assert_eq!(983, longest_palindrome_from_rearrange("civilwartestingwhetherthatnaptionoranynartionsoconceivedandsodedicatedcanlongendureWeareqmetonagreatbattlefiemldoftzhatwarWehavecometodedicpateaportionofthatfieldasafinalrestingplaceforthosewhoheregavetheirlivesthatthatnationmightliveItisaltogetherfangandproperthatweshoulddothisButinalargersensewecannotdedicatewecannotconsecratewecannothallowthisgroundThebravelmenlivinganddeadwhostruggledherehaveconsecrateditfaraboveourpoorponwertoaddordetractTgheworldadswfilllittlenotlenorlongrememberwhatwesayherebutitcanneverforgetwhattheydidhereItisforusthelivingrathertobededicatedheretotheulnfinishedworkwhichtheywhofoughtherehavethusfarsonoblyadvancedItisratherforustobeherededicatedtothegreattdafskremainingbeforeusthatfromthesehonoreddeadwetakeincreaseddevotiontothatcauseforwhichtheygavethelastpfullmeasureofdevotionthatweherehighlyresolvethatthesedeadshallnothavediedinvainthatthisnationunsderGodshallhaveanewbirthoffreedomandthatgovernmentofthepeoplebythepeopleforthepeopleshallnotperishfromtheearth".to_string()));
    }

    #[test]
    fn convert_test() {
        assert_eq!("abcde".to_string(), convert("abcde".to_string(), 1));
        assert_eq!("acebd".to_string(), convert("abcde".to_string(), 2));
        assert_eq!("aibhjcgkdflem".to_string(), convert("abcdefghijklm".to_string(), 5));
        assert_eq!("PAHNAPLSIIGYIR".to_string(), convert("PAYPALISHIRING".to_string(), 3));
        assert_eq!("PINALSIGYAHRPI".to_string(), convert("PAYPALISHIRING".to_string(), 4));
        assert_eq!("a".to_string(), convert("a".to_string(), 1));
        println!("{}", convert("PAYPALISHIRING".to_string(), 3));
    }

    #[test]
    fn longest_palindrome_test() {
        assert_eq!("yxaaxy".to_string(), longest_palindrome("byxaaxyd".to_string()));
        assert_eq!("yxaaxy".to_string(), longest_palindrome("yxaaxyd".to_string()));
        assert_eq!("yxaaxy".to_string(), longest_palindrome("byxaaxy".to_string()));
        assert_eq!("yxaxy".to_string(), longest_palindrome("byxaxyd".to_string()));
        assert_eq!("yxaxy".to_string(), longest_palindrome("byxaxy".to_string()));
        assert_eq!("bab".to_string(), longest_palindrome("babad".to_string()));
        assert_eq!("bb".to_string(), longest_palindrome("cbbd".to_string()));
        assert_eq!("abba".to_string(), longest_palindrome("cabbad".to_string()));
        assert_eq!("a".to_string(), longest_palindrome("abcde".to_string()));
        assert_eq!("aaaa".to_string(), longest_palindrome("aaaa".to_string()));
        assert_eq!("aaaaa".to_string(), longest_palindrome("aaaaa".to_string()));
        assert_eq!("aaaaa".to_string(), longest_palindrome("aaaaaxyz".to_string()));
        assert_eq!("aaaaa".to_string(), longest_palindrome("xyzaaaaaxyz".to_string()));
        assert_eq!("axyxa".to_string(), longest_palindrome("aaaxyxa".to_string()));
        assert_eq!("aaaaaaa".to_string(), longest_palindrome("aaaaaaaxaaa".to_string()));
        assert_eq!("yzy".to_string(), longest_palindrome("yzy".to_string()));
        assert_eq!("yzzy".to_string(), longest_palindrome("yzzy".to_string()));
        assert_eq!("yzzzy".to_string(), longest_palindrome("yzzzy".to_string()));
        assert_eq!("yzzzzy".to_string(), longest_palindrome("yzzzzy".to_string()));
        assert_eq!("zzyzz".to_string(), longest_palindrome("zzyzzz".to_string()));
        assert_eq!("sooos".to_string(), longest_palindrome("azwdzwmwcqzgcobeeiphemqbjtxzwkhiqpbrprocbppbxrnsxnwgikiaqutwpftbiinlnpyqstkiqzbggcsdzzjbrkfmhgtnbujzszxsycmvipjtktpebaafycngqasbbhxaeawwmkjcziybxowkaibqnndcjbsoehtamhspnidjylyisiaewmypfyiqtwlmejkpzlieolfdjnxntonnzfgcqlcfpoxcwqctalwrgwhvqvtrpwemxhirpgizjffqgntsmvzldpjfijdncexbwtxnmbnoykxshkqbounzrewkpqjxocvaufnhunsmsazgibxedtopnccriwcfzeomsrrangufkjfzipkmwfbmkarnyyrgdsooosgqlkzvorrrsaveuoxjeajvbdpgxlcrtqomliphnlehgrzgwujogxteyulphhuhwyoyvcxqatfkboahfqhjgujcaapoyqtsdqfwnijlkknuralezqmcryvkankszmzpgqutojoyzsnyfwsyeqqzrlhzbc".to_string()));
        let a = "aaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkkkkkkkkkkllllllllllmmmmmmmmmmnnnnnnnnnnooooooooooppppppppppqqqqqqqqqqrrrrrrrrrrssssssssssttttttttttuuuuuuuuuuvvvvvvvvvvwwwwwwwwwwxxxxxxxxxxyyyyyyyyyyzzzzzzzzzzyyyyyyyyyyxxxxxxxxxxwwwwwwwwwwvvvvvvvvvvuuuuuuuuuuttttttttttssssssssssrrrrrrrrrrqqqqqqqqqqppppppppppoooooooooonnnnnnnnnnmmmmmmmmmmllllllllllkkkkkkkkkkjjjjjjjjjjiiiiiiiiiihhhhhhhhhhggggggggggffffffffffeeeeeeeeeeddddddddddccccccccccbbbbbbbbbbaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkkkkkkkkkkllllllllllmmmmmmmmmmnnnnnnnnnnooooooooooppppppppppqqqqqqqqqqrrrrrrrrrrssssssssssttttttttttuuuuuuuuuuvvvvvvvvvvwwwwwwwwwwxxxxxxxxxxyyyyyyyyyyzzzzzzzzzzyyyyyyyyyyxxxxxxxxxxwwwwwwwwwwvvvvvvvvvvuuuuuuuuuuttttttttttssssssssssrrrrrrrrrrqqqqqqqqqqppppppppppoooooooooonnnnnnnnnnmmmmmmmmmmllllllllllkkkkkkkkkkjjjjjjjjjjiiiiiiiiiihhhhhhhhhhggggggggggffffffffffeeeeeeeeeeddddddddddccccccccccbbbbbbbbbbaaaa".to_string();
        let b = "aaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkkkkkkkkkkllllllllllmmmmmmmmmmnnnnnnnnnnooooooooooppppppppppqqqqqqqqqqrrrrrrrrrrssssssssssttttttttttuuuuuuuuuuvvvvvvvvvvwwwwwwwwwwxxxxxxxxxxyyyyyyyyyyzzzzzzzzzzyyyyyyyyyyxxxxxxxxxxwwwwwwwwwwvvvvvvvvvvuuuuuuuuuuttttttttttssssssssssrrrrrrrrrrqqqqqqqqqqppppppppppoooooooooonnnnnnnnnnmmmmmmmmmmllllllllllkkkkkkkkkkjjjjjjjjjjiiiiiiiiiihhhhhhhhhhggggggggggffffffffffeeeeeeeeeeddddddddddccccccccccbbbbbbbbbbaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkkkkkkkkkkllllllllllmmmmmmmmmmnnnnnnnnnnooooooooooppppppppppqqqqqqqqqqrrrrrrrrrrssssssssssttttttttttuuuuuuuuuuvvvvvvvvvvwwwwwwwwwwxxxxxxxxxxyyyyyyyyyyzzzzzzzzzzyyyyyyyyyyxxxxxxxxxxwwwwwwwwwwvvvvvvvvvvuuuuuuuuuuttttttttttssssssssssrrrrrrrrrrqqqqqqqqqqppppppppppoooooooooonnnnnnnnnnmmmmmmmmmmllllllllllkkkkkkkkkkjjjjjjjjjjiiiiiiiiiihhhhhhhhhhggggggggggffffffffffeeeeeeeeeeddddddddddccccccccccbbbbbbbbbbaaaa".to_string();
        println!("len: {}/{}  mid: {} ", a.len(), b.len(), a.len() / 2);
        assert_eq!(a, longest_palindrome(b));
    }

    #[test]
    fn find_the_difference_test() {
        assert_eq!('e', find_the_difference_1("abcd".to_string(), "abcde".to_string()));
        assert_eq!('y', find_the_difference_1("".to_string(), "y".to_string()));
        assert_eq!('y', find_the_difference_1("hello".to_string(), "heyllo".to_string()));
        assert_eq!('y', find_the_difference_1("heyllo".to_string(), "heyyllo".to_string()));

        assert_eq!('e', find_the_difference("abcd".to_string(), "abcde".to_string()));
        assert_eq!('y', find_the_difference("".to_string(), "y".to_string()));
        assert_eq!('y', find_the_difference("hello".to_string(), "heyllo".to_string()));
        assert_eq!('y', find_the_difference("heyllo".to_string(), "heyyllo".to_string()));
    }

    #[test]
    fn first_unique_char_test() {
        assert_eq!(first_uniq_char("leetcode".to_string()), 0);
        assert_eq!(first_uniq_char("loveleetcode".to_string()), 2);
        assert_eq!(first_uniq_char("aabb".to_string()), -1);
    }

    #[test]
    fn can_construct_test() {
        assert!(!can_construct("a".to_string(), "b".to_string()));
        assert!(!can_construct("aa".to_string(), "ab".to_string()));
        assert!(can_construct("aa".to_string(), "aab".to_string()));
        assert!(can_construct("aa".to_string(), "baa".to_string()));
        assert!(can_construct("aa".to_string(), "aba".to_string()));
        assert!(can_construct("aab".to_string(), "aba".to_string()));
    }

    #[test]
    fn is_anagram_test() {
        assert!(is_anagram("anagram".to_string(), "nagaram".to_string()));
        assert!(!is_anagram("rat".to_string(), "cat".to_string()));
    }

    #[test]
    fn is_isomorphic_test() {
        assert!(is_isomorphic("egg".to_string(), "add".to_string()));
        assert!(!is_isomorphic("foo".to_string(), "bar".to_string()));
        assert!(is_isomorphic("paper".to_string(), "title".to_string()));
        assert!(!is_isomorphic("badc".to_string(), "baba".to_string()));
    }
}